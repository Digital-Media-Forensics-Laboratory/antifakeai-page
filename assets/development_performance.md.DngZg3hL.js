import{_ as o,c as l,a0 as n,j as i,a as t,G as e,B as d,o as r}from"./chunks/framework.BD2nrhTt.js";const B=JSON.parse('{"title":"性能主题","description":"","frontmatter":{"outline":[2,4]},"headers":[],"relativePath":"development/performance.md","filePath":"development/performance.md","lastUpdated":1748312930000}'),p={name:"development/performance.md"},h={id:"数据升维",tabindex:"-1"},k={id:"数据降维",tabindex:"-1"},c={id:"场景三-1",tabindex:"-1"},g={id:"数组操纵",tabindex:"-1"};function y(b,a,E,u,m,f){const s=d("Badge");return r(),l("div",null,[a[12]||(a[12]=n('<h1 id="性能主题" tabindex="-1">性能主题 <a class="header-anchor" href="#性能主题" aria-label="Permalink to &quot;性能主题&quot;">​</a></h1><p>本专题针对平台二次开发、python模型开发过程中的性能优化部分做出通用性的建议。</p><h2 id="模型开发" tabindex="-1">模型开发 <a class="header-anchor" href="#模型开发" aria-label="Permalink to &quot;模型开发&quot;">​</a></h2><p>在应用场景中，模型的性能主要取决于模型推理速度，这由模型结构设计、GPU推理性能、模型量化等因素综合决定。然而，在开发过程中，依旧有诸多因素会影响性能，例如，由于推理与训练不同，可能会从文件直接获取数据，而非如训练时一样，通过封装好的<code>DataLoader</code>来读取数据。</p><div class="info custom-block"><p class="custom-block-title">数据加载类 <code>DataLoader</code></p><p>TODO</p></div><p>此外，许多模型并非简单地接受数据，有时会需要加上各类的预处理操作。尽管预处理操作的底层设计通常是高效的，但由于 Python 语言本身性能较弱以及开发者经验不足，无法编写出高效率的 Python 代码，导致程序存在性能问题。</p><p>本节聚焦 Python 语言特性，对于开发过程中的常见操作给出通用性的建议。一般来说，性能高的Python代码有如下特点：</p><ol><li><strong>短</strong>。通常越短的代码越快，例如简单的迭代操作可以用列表推导式完成。尽管这并非绝对，但是对于一般场景，几乎没有例外，除非你有扎实的编程基础，否则你可以认为这句话是对的。更加简单的来说，那就是代码的 <strong>for 循环代码块</strong> 越少，性能越好。</li><li><strong>向量化运算</strong>。对于处理数据的场景，例如相加两个长度为3的向量 <code>a = np.array([1,2,3])</code> 和 <code>b = np.array([2,4,6])</code>，通常可以<code>a + b</code>直接相加，而非使用循环对每一个元素相加。其内涵就是向量化运算。在本质上依旧是 <strong>for 循环</strong> 越少，性能越好。</li><li><strong>并行</strong>。对于多核心的CPU，并行处理可以显著加快速度。第 2 条的向量化本质就是并行。然而python并不擅长并行，但好在常用的库，如numpy，它们底层由C/C++编写，已经实现了并行。因此，在这里我们只需掌握简单的多进程应用就行。</li></ol><h3 id="数据处理部分" tabindex="-1">数据处理部分 <a class="header-anchor" href="#数据处理部分" aria-label="Permalink to &quot;数据处理部分&quot;">​</a></h3><p>本节介绍一些高频的数据操作，包括numpy、torch使用时的典型操作。这些操作在日常使用时经常用到，请熟练使用。</p>',10)),i("h4",h,[a[0]||(a[0]=t("数据升维 ")),e(s,{type:"danger",text:"重要"}),a[1]||(a[1]=t()),a[2]||(a[2]=i("a",{class:"header-anchor",href:"#数据升维","aria-label":'Permalink to "数据升维 <Badge type="danger" text="重要" />"'},"​",-1))]),a[13]||(a[13]=n(`<p>以下是一些高频出现的场景，请熟练应用。</p><h5 id="场景一" tabindex="-1">场景一 <a class="header-anchor" href="#场景一" aria-label="Permalink to &quot;场景一&quot;">​</a></h5><p>有一张<code>(3, 512, 512)</code>的图像，需要放入神经网络推理，但是模型接受的输入尺寸是<code>( b, c, h, w )</code>，也就是缺少了一个batch size维度。请处理这张图像，使之符合<code>(1, 3, 512, 512)</code>的输入尺寸。</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-RsTp8" id="tab-ZIoELvK" checked><label data-title="numpy" for="tab-ZIoELvK">numpy</label><input type="radio" name="group-RsTp8" id="tab-JECF0Ql"><label data-title="torch" for="tab-JECF0Ql">torch</label></div><div class="blocks"><div class="language-python vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.random.randn(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">512</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">512</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> ??</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> torch.randn(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">512</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">512</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> ??</span></span></code></pre></div></div></div><h5 id="场景二" tabindex="-1">场景二 <a class="header-anchor" href="#场景二" aria-label="Permalink to &quot;场景二&quot;">​</a></h5><p>有两张相同尺寸的RGB图像被读取为 <code>img1</code> 和 <code>img2</code>，请将它们组合成一个<code>(2, c, h, w)</code> 的输入。</p><h5 id="场景三" tabindex="-1">场景三 <a class="header-anchor" href="#场景三" aria-label="Permalink to &quot;场景三&quot;">​</a></h5><p>有<code>n</code>张相同尺寸的RGB图像文件路径保存在一个list里，请将它们组合成<code>(n, c, h, w)</code> 的输入。</p>`,8)),i("h4",k,[a[3]||(a[3]=t("数据降维 ")),e(s,{type:"danger",text:"重要"}),a[4]||(a[4]=t()),a[5]||(a[5]=i("a",{class:"header-anchor",href:"#数据降维","aria-label":'Permalink to "数据降维 <Badge type="danger" text="重要" />"'},"​",-1))]),a[14]||(a[14]=n('<p>数据降维也是比较常见的场景。现列举一些比较经典的应用。</p><h5 id="场景一-1" tabindex="-1">场景一 <a class="header-anchor" href="#场景一-1" aria-label="Permalink to &quot;场景一&quot;">​</a></h5><p>一张图像以<code>(1, 3, 512, 512)</code>的形状输入一个<strong>四分类器</strong>，最终得到了<code>(1, 4)</code>的二维数组，其中输出的第一维是batch size，第二维是4个类别对应的置信度。请将输出的二维数组转化成一个普通的一维数组，即<code>(4, )</code>。</p><h5 id="场景二-1" tabindex="-1">场景二 <a class="header-anchor" href="#场景二-1" aria-label="Permalink to &quot;场景二&quot;">​</a></h5><p>现有一批图像组成了一个 Batch，形状为<code>(16, 3, 512, 512)</code>。现在模型只接受单通道的图像，即输入形状为<code>(b, 512, 512)</code>，<code>b</code> 为 batch size。请将原始数据 RGB 三通道中的<code>G</code>通道变换，使之匹配神经网络的输入形状。</p>',5)),i("h5",c,[a[6]||(a[6]=t("场景三 ")),e(s,{type:"warning",text:"拓展"}),a[7]||(a[7]=t()),a[8]||(a[8]=i("a",{class:"header-anchor",href:"#场景三-1","aria-label":'Permalink to "场景三 <Badge type="warning" text="拓展" />"'},"​",-1))]),a[15]||(a[15]=i("p",null,[t("模型规则同"),i("strong",null,"场景二"),t("，但输入图像只有一张，并组成了batch，即形状为"),i("code",null,"(1, 3, 512, 512)"),t("。请给出对应的变换。")],-1)),i("h4",g,[a[9]||(a[9]=t("数组操纵 ")),e(s,{type:"tip",text:"常见"}),a[10]||(a[10]=t()),a[11]||(a[11]=i("a",{class:"header-anchor",href:"#数组操纵","aria-label":'Permalink to "数组操纵 <Badge type="tip" text="常见" />"'},"​",-1))]),a[16]||(a[16]=i("p",null,"一些数组变换极其常见，可以学习这些方案，需要用到时可以采用。",-1)),a[17]||(a[17]=i("h5",{id:"场景一-2",tabindex:"-1"},[t("场景一 "),i("a",{class:"header-anchor",href:"#场景一-2","aria-label":'Permalink to "场景一"'},"​")],-1)),a[18]||(a[18]=i("p",null,[t("现在我有一批数据，已经组成了一个大小为 15 的 Batch，形状"),i("code",null,"(15, 3, 512, 512)"),t("。现有一个新的图像，尺寸与通道跟 Batch 里的数据一致，希望把它加入这个Batch，即组成一个形状"),i("code",null,"(16, 3, 512, 512)"),t("的 Batch。请实现这一功能。")],-1))])}const x=o(p,[["render",y]]);export{B as __pageData,x as default};
